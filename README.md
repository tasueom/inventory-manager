# 📦 Inventory Manager (재고 관리 시스템)

다수의 사용자가 동시에 접근하는 환경에서도 정확한 재고 수량을 보장할 수 있도록 설계된 **풀스택 재고 관리 프로젝트**입니다. 단순히 기능을 구현하는 것에 그치지 않고, 백엔드 동시성 제어와 **Docker Compose를 활용한 인프라 자동화**에 초점을 맞췄습니다.

---

## 📋 목차

- [주요 기능](#주요-기능)
- [기술적 도전 (동시성 제어)](#-기술적-도전-동시성-제어)
- [기술 스택](#기술-스택)
- [인프라 및 배포 구조](#-인프라-및-배포-구조)
- [실행 방법 (Docker Compose)](#-실행-방법-docker-compose)
- [프로젝트 구조](#-프로젝트-구조)

---

## 주요 기능

### 👤 사용자 모드 (User Mode)

- **실시간 재고 구매**: 전체 상품 목록을 조회하고 실시간으로 재고를 차감하는 구매 프로세스를 수행합니다.
- **데이터 정합성 보장**: 낙관적 락(Optimistic Lock)을 적용하여 동시 주문 시에도 정확한 수량을 유지합니다.

### 🛡️ 관리자 모드 (Admin Mode)

- **재고 수정 및 관리**: 상품 정보(이름, 단가, 수량)를 자유롭게 관리하고 새로운 품목을 등록합니다.
- **통합 관리 UI**: 관리자 권한 전용 대시보드를 통해 전체 재고 현황을 효율적으로 파악합니다.

---

## 🚀 기술적 도전 (동시성 제어)

재고 관리 시스템에서 가장 치명적인 **'동시 요청 시 데이터 유실'** 문제를 해결하기 위해 다음과 같은 과정을 거쳤습니다.

### 1. 문제 상황 인식

- 다수의 사용자가 동시에 동일 상품을 구매할 경우, 경쟁 상태가 발생하여 데이터가 유실되거나 실제보다 더 많은 주문이 처리될 위험을 확인했습니다.

### 2. 해결책: JPA 낙관적 락 (Optimistic Lock)

- **도입 이유**: 데이터 충돌 빈도가 낮을 것으로 예상되는 환경에서 시스템 부하를 최소화하기 위해, 데이터베이스 락 대신 애플리케이션 레벨에서 버전을 검증하는 `@Version` 방식을 선택했습니다.
- **구현**: 엔티티 내부에 버전 관리 필드를 추가하여 수정 시점의 데이터 유효성을 검증하도록 설계했습니다.

### 3. 검증: JUnit 멀티스레드 테스트

- `ExecutorService`와 `CountDownLatch`를 활용하여 30개의 요청이 동시에 발생하는 극한의 환경을 시뮬레이션했습니다.
- **테스트 결과**: 30건의 동시 요청 중 9건 성공, 21건 충돌 감지를 통해
  동시성 상황에서도 재고 수량이 음수로 내려가지 않음을 검증했습니다.

---

## 🛠 기술 스택

| 구분         | 상세 기술                                   |
| :----------- | :------------------------------------------ |
| **Backend**  | Java 17, Spring Boot 3.5.8, Spring Data JPA |
| **Frontend** | React (Vite), TypeScript, Axios             |
| **Database** | MySQL 8.0                                   |
| **Infra**    | **Docker, Docker Compose**                  |
| **Test**     | JUnit 5, AssertJ                            |

---

## 🏗 인프라 및 배포 구조

이 프로젝트는 **Docker Compose**를 통해 각 계층을 컨테이너화하고 유기적으로 연결하여 인프라를 구축했습니다.

- **Frontend**: Vite로 빌드한 정적 파일을 Nginx 컨테이너를 통해 서빙하여,
  개발/배포 환경 간 실행 차이를 최소화했습니다.
- **Backend**: Spring Boot 애플리케이션을 이미지화하여 환경 독립성을 확보했습니다.
- **Database**: MySQL 컨테이너를 가상 네트워크로 연결하여 외부 노출을 최소화하고 보안성을 높였습니다.
- **Environment**: Docker Compose 환경에서는 테스트 목적의 계정 정보를 사용했으며,
  실제 운영 환경에서는 민감 정보는 환경 변수 또는 별도 설정으로 분리하는 구조를 고려했습니다.

---

## 🐋 실행 방법 (Docker Compose)

### 1) 프로젝트 루트로 이동

```bash
cd "프로젝트 폴더 주소"
```

### 2) Docker Compose로 실행

```bash
docker compose up -d --build
```

### 3) 종료

```bash
docker compose down
```

---

### 환경 설정 값

이 프로젝트는 `docker-compose.yml`에 실행에 필요한 값들이 이미 포함되어 있습니다.

- DB 계정/비밀번호 및 DB 생성 정보  
  (`MYSQL_ROOT_PASSWORD`, `MYSQL_DATABASE`, `MYSQL_USER`, `MYSQL_PASSWORD`)
- Backend DB 접속 정보  
  (`SPRING_DATASOURCE_URL`, `SPRING_DATASOURCE_USERNAME`, `SPRING_DATASOURCE_PASSWORD`)
- Frontend API Base URL (빌드 시 주입)  
  (`VITE_API_BASE_URL = http://localhost:8090/api/inventory`)

---

## 📈 성장 기록

- **타입 안정성 확보**: JavaScript 환경에서 발생하던 런타임 에러를 방지하기 위해 전체 프로젝트를 **TypeScript**로 전환했습니다.
- **전역 예외 처리**: `@RestControllerAdvice`를 도입하여 백엔드 에러 응답 규격을 일원화하고 프론트엔드 대응 효율을 높였습니다.
- **데이터 정합성 및 검증**: 재고 차감 시 발생하는 동시성 문제를 **낙관적 락**으로 해결하고, **JUnit 5**를 활용해 멀티스레드 환경에서의 정합성을 코드로 직접 증명했습니다.
- **인프라 자동화**: Docker를 도입하여 로컬 환경과 배포 환경의 격차를 해소하고 Docker Compose로 원클릭 실행 환경을 구축했습니다.
